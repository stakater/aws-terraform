<?xml version="1.0" encoding="utf-8"?>
<cruise xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="cruise-config.xsd" schemaVersion="81">
  <server artifactsdir="artifacts" agentAutoRegisterKey="123456789ytrewq" commandRepositoryLocation="default" serverId="e89d0b81-9c38-4e25-a946-ac1dc6944233" />
  <pipelines group="StakaterPipelines">
    <pipeline name="MyApplication" template="Stakater_Template">
      <params>
        <param name="SOURCE_DIR" />
        <param name="BUILD_DOCKER_IMAGE"></param>
        <param name="BUILD_DOCKER_IMAGE_OPTS"></param>
        <param name="BUILT_WAR_FILE"></param>
        <param name="APP_COMPILE_CMD"></param>
        <param name="APP_TEST_CMD"></param>
        <param name="APP_PACKAGE_CMD"></param>
        <param name="APP_TEST_ARTIFACT">/</param>
        <param name="APP_IMAGE_BUILD_DIR">./myApplication</param>
        <param name="APP_IMAGE_BUILD_VERSION">${GO_PIPELINE_COUNTER}.${GO_STAGE_COUNTER}</param>
        <param name="APP_NAME">MyApplication</param>
        <param name="DOCKER_REGISTRY"></param>
        <param name="APP_DOCKER_IMAGE"></param>
        <param name="APP_DOCKER_OPTS"></param>
      </params>
      <materials>
        <git url="" branch="master" />
      </materials>
    </pipeline>
  </pipelines>
  <templates>
    <pipeline name="Stakater_Template">
      <stage name="Compile">
        <jobs>
          <job name="Compile">
            <tasks>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker run -d --name build_img_${GO_PIPELINE_NAME} #{BUILD_DOCKER_IMAGE_OPTS} #{BUILD_DOCKER_IMAGE}</arg>
                <runif status="any" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker cp ./ build_img_${GO_PIPELINE_NAME}:/app</arg>
                <runif status="passed" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker exec build_img_${GO_PIPELINE_NAME} /bin/bash -c "#{APP_COMPILE_CMD}"</arg>
                <runif status="passed" />
              </exec>
            </tasks>
          </job>
        </jobs>
      </stage>
      <stage name="Test" fetchMaterials="false">
        <jobs>
          <job name="Unit_Test">
            <tasks>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker exec build_img_${GO_PIPELINE_NAME} /bin/bash -c "#{APP_TEST_CMD}"</arg>
                <runif status="any" />
              </exec>
            </tasks>
            <artifacts>
              <test src="#{APP_TEST_ARTIFACT}" />
            </artifacts>
          </job>
        </jobs>
      </stage>
      <stage name="Package" fetchMaterials="false">
        <jobs>
          <job name="Package">
            <tasks>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker exec build_img_${GO_PIPELINE_NAME} /bin/bash -c "#{APP_PACKAGE_CMD}"</arg>
                <runif status="any" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker cp build_img_${GO_PIPELINE_NAME}:#{BUILT_WAR_FILE} #{APP_IMAGE_BUILD_DIR}/</arg>
                <runif status="passed" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker stop build_img_${GO_PIPELINE_NAME}</arg>
                <runif status="any" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker rm -v build_img_${GO_PIPELINE_NAME}</arg>
                <runif status="any" />
              </exec>
            </tasks>
          </job>
        </jobs>
      </stage>
      <stage name="Publish-Docker-Image" fetchMaterials="false">
        <jobs>
          <job name="Publish">
            <tasks>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker build -t #{APP_DOCKER_IMAGE} #{APP_IMAGE_BUILD_DIR}</arg>
                <runif status="passed" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker push #{APP_DOCKER_IMAGE}</arg>
                <runif status="passed" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>newTag=#{APP_DOCKER_IMAGE}:#{APP_IMAGE_BUILD_VERSION};\
                     sudo docker tag -f #{APP_DOCKER_IMAGE} ${newTag}</arg>
                <runif status="passed" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>newTag=#{APP_DOCKER_IMAGE}:#{APP_IMAGE_BUILD_VERSION};\
                     sudo docker push ${newTag};
                     echo "Delete Empty Docker Images ...";
                     deleteImage()
                     {
                        images="sudo docker images | grep 'none' | awk '{print $3}' | xargs sudo docker rmi"
                        echo "Deleting images..."
                        bash -c "$images"
                     }

                     cmd="sudo docker images | grep 'none'"
                     count=$(bash -c "$cmd")
                     echo $count
                     if [ -n "$count" ]
                     then
                       deleteImage || true
                       echo "Images Deleted Successfully!"
                     else
                       echo "No empty Docker images found."
                     fi</arg>
                <runif status="passed" />
              </exec>
            </tasks>
          </job>
        </jobs>
      </stage>
      <stage name="Make-AMI" fetchMaterials="false">
        <approval type="manual" />
        <jobs>
          <job name="Run">
            <tasks>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>if [ ! -d "/app/amibaker" ]; then sudo mkdir -p /app/amibaker;fi;  \
                    if [ ! "$(ls -A /app/amibaker)" ]; then sudo git clone https://github.com/stakater/ami-baker.git /app/amibaker; fi</arg>
                <runif status="passed" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>cd /app/amibaker;sudo git pull origin master;</arg>
                <runif status="passed" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker run -d --name packer_${GO_PIPELINE_NAME} -v /app/amibaker:/usr/src/app stakater/packer</arg>
                <runif status="any" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo cp -f /etc/registry_certificates/ca.crt /app/amibaker/baker-data/ca.crt;
                     macAddress=$(curl -s http://169.254.169.254/latest/meta-data/network/interfaces/macs/);
                     vpc_id=$(curl -s http://169.254.169.254/latest/meta-data/network/interfaces/macs/$macAddress/vpc-id);
                     subnet_id=$(curl -s http://169.254.169.254/latest/meta-data/network/interfaces/macs/$macAddress/subnet-id);
                     aws_region=$(curl -s http://169.254.169.254/latest/dynamic/instance-identity/document|grep region|awk -F\" '{print $4}');
                     docker_registry_path="/etc/docker/certs.d/#{DOCKER_REGISTRY}"
                     sudo docker exec packer_${GO_PIPELINE_NAME} /bin/bash -c  "./bake-ami.sh -r $aws_region -v $vpc_id -s $subnet_id \
                                                                                -n #{APP_NAME}_#{APP_IMAGE_BUILD_VERSION} -d #{APP_DOCKER_IMAGE} \
                                                                                -o \"#{APP_DOCKER_OPTS}\" -g $docker_registry_path"</arg>
                <runif status="passed" />
              </exec>
              <exec command="/bin/bash" workingdir="#{SOURCE_DIR}">
                <arg>-c</arg>
                <arg>sudo docker rm -vf packer_${GO_PIPELINE_NAME}</arg>
                <runif status="any" />
              </exec>
            </tasks>
          </job>
        </jobs>
      </stage>
    </pipeline>
  </templates>
  <agents>
  </agents>
</cruise>

